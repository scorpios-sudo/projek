<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Trader X • Exchange (TradingView integrated)</title>
  <script src="https://s3.tradingview.com/tv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:#0a0f17; --panel:#111725; --border:#1b2333; --muted:#93a1b3; --text:#e7edf5;
      --accent:#00e0a4; --yellow:#f0b90b; --buy:#00c389; --sell:#ff5c7a;
    }
    * { box-sizing: border-box }
    body { margin:0; background:var(--bg); color:var(--text); font-family:Inter,system-ui,Arial; }
    header { padding:12px 16px; display:flex; align-items:center; gap:12px; border-bottom:1px solid var(--border); }
    header .brand { font-weight:900; color:var(--yellow); }
    header .pair { color:var(--muted); font-weight:700; }
    .tabs { margin-left:auto; display:flex; gap:8px; }
    .tab { padding:6px 10px; border:1px solid var(--border); background:#0d1422; color:var(--muted); border-radius:8px; cursor:pointer; }
    .tab.active { background:var(--yellow); color:#0b0f17; font-weight:800; border-color:#d19c0a; }

    main.layout { display:grid; grid-template-columns: 2fr 1fr; grid-template-rows: auto auto; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:12px; overflow:hidden; }
    .panel h2 { margin:0; padding:10px 12px; font-size:13px; border-bottom:1px solid var(--border); color:var(--muted); }
    .content { padding:12px; }

    .metrics { display:flex; gap:12px; flex-wrap:wrap; margin-bottom:8px; }
    .metric { background:#0e1422; border:1px solid #283042; border-radius:10px; padding:8px 10px; }
    .metric .label { font-size:11px; color:var(--muted); }
    .metric .value { font-size:16px; font-weight:800; margin-top:2px; }

    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input, select { width:100%; padding:10px; border-radius:10px; border:1px solid #283042; background:#0f1421; color:var(--text); }

    .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .btn { padding:10px 12px; border:none; border-radius:10px; font-weight:700; cursor:pointer; }
    .btn.buy { background:var(--buy); color:#06140f; }
    .btn.sell { background:var(--sell); color:#2b0a11; }
    .btn.secondary { background:#1c2333; color:var(--text); border:1px solid #283042; }
    .btn.ghost { background:transparent; color:var(--muted); border:1px dashed #2b3448; }

    .quick { display:flex; gap:6px; margin-top:8px; }
    .quick button { flex:1; padding:8px; background:#0f1422; color:#b9c3cf; border:1px solid #2a3246; border-radius:8px; cursor:pointer; }
    .quick button:hover { background:var(--accent); color:#0b0f17; }

    table { width:100%; border-collapse:collapse; }
    th, td { font-size:12px; padding:6px 4px; border-bottom:1px solid var(--border); }
    th { color:var(--muted); text-align:right; }
    td { text-align:right; }
    .buyText { color:#8fffd3; }
    .sellText { color:#ffa1b3; }

    .depthWrap { height:220px; }
    canvas { max-height: 340px; }

    @media (max-width:1000px){
      main.layout { grid-template-columns:1fr; grid-template-rows:auto auto auto auto; }
    }
    #tvChart { height: 420px; }
  </style>
</head>
<body>
  <header>
    <div class="brand">Trader X</div>
    <div class="pair" id="currentPair">BTC/IDR</div>
    <div class="tabs">
      <div class="tab active" data-pair="BTC/IDR">BTC/IDR</div>
      <div class="tab" data-pair="ETH/IDR">ETH/IDR</div>
      <div class="tab" data-pair="DOGE/IDR">DOGE/IDR</div>
    </div>
  </header>

  <main class="layout">
    <!-- Left: TradingView Chart + summary -->
    <section class="panel">
      <h2>TradingView chart</h2>
      <div class="content">
        <div class="metrics">
          <div class="metric"><div class="label">Last</div><div class="value" id="mLast">—</div></div>
          <div class="metric"><div class="label">Bid</div><div class="value" id="mBid">—</div></div>
          <div class="metric"><div class="label">Ask</div><div class="value" id="mAsk">—</div></div>
          <div class="metric"><div class="label">Spread</div><div class="value" id="mSpread">—</div></div>
          <div class="metric"><div class="label">24h change</div><div class="value" id="mChange">—</div></div>
          <div class="metric"><div class="label">24h high</div><div class="value" id="mHigh">—</div></div>
          <div class="metric"><div class="label">24h low</div><div class="value" id="mLow">—</div></div>
          <div class="metric"><div class="label">24h vol</div><div class="value" id="mVol">—</div></div>
        </div>
        <div id="tvChart"></div>
      </div>
    </section>

    <!-- Right: Depth chart -->
    <section class="panel">
      <h2>Depth chart (bid/ask)</h2>
      <div class="content depthWrap">
        <canvas id="depthChart"></canvas>
      </div>
    </section>

    <!-- Left bottom: Order entry -->
    <section class="panel">
      <h2>Order entry</h2>
      <div class="content">
        <div class="grid2">
          <div>
            <label>Order type</label>
            <select id="orderType">
              <option value="market">Market</option>
              <option value="limit">Limit</option>
            </select>
          </div>
          <div>
            <label>Side</label>
            <select id="orderSide">
              <option value="buy">Buy</option>
              <option value="sell">Sell</option>
            </select>
          </div>
        </div>

        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Harga (IDR) — limit only</label>
            <input type="number" id="price" placeholder="contoh: 950000000"/>
          </div>
          <div>
            <label>Qty (base)</label>
            <input type="number" id="qty" placeholder="contoh: 0.01"/>
          </div>
        </div>

        <div class="quick">
          <button data-q="25">25%</button>
          <button data-q="50">50%</button>
          <button data-q="75">75%</button>
          <button data-q="100">100%</button>
        </div>

        <div class="actions">
          <button class="btn buy" id="placeBuy">Place BUY</button>
          <button class="btn sell" id="placeSell">Place SELL</button>
          <button class="btn secondary" id="reset">Reset</button>
          <button class="btn ghost" id="cancelBids">Cancel bids</button>
          <button class="btn ghost" id="cancelAsks">Cancel asks</button>
          <button class="btn ghost" id="clearTrades">Clear trades</button>
        </div>

        <div class="metrics" style="margin-top:10px;">
          <div class="metric"><div class="label">Saldo IDR</div><div class="value" id="balIDR">—</div></div>
          <div class="metric"><div class="label">Saldo Base</div><div class="value" id="balBase">—</div></div>
          <div class="metric"><div class="label">Fee</div><div class="value">Taker 0.1% • Maker 0.0%</div></div>
        </div>
      </div>
    </section>

    <!-- Right bottom: Recent trades -->
    <section class="panel">
      <h2>Recent trades</h2>
      <div class="content" style="max-height:260px; overflow:auto;">
        <table>
          <thead><tr><th style="text-align:left">Waktu</th><th>Harga</th><th>Qty</th><th>Nilai</th><th>Side</th></tr></thead>
          <tbody id="tradesBody"></tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    // ===== Symbols for TradingView per pair =====
    const TV_SYMBOLS = {
      'BTC/IDR': 'INDODAX:BTCIDR',  // fallback later to BINANCE:BTCUSDT if needed
      'ETH/IDR': 'BINANCE:ETHUSDT',
      'DOGE/IDR': 'BINANCE:DOGEUSDT'
    };

    let tvWidget = null;
    function mountTV(symbol){
      if(tvWidget){ tvWidget.remove(); tvWidget = null; }
      tvWidget = new TradingView.widget({
        symbol,
        interval: '15',
        container_id: 'tvChart',
        autosize: true,
        locale: 'id',
        hide_top_toolbar: false,
        hide_legend: false,
        save_image: false,
        studies: ['Volume@tv-basicstudies'],
        disabled_features: ['use_localstorage_for_settings'],
        theme: 'dark'
      });
    }

    // ===== Utilities =====
    const fmtIDR = v => new Intl.NumberFormat('id-ID', { style:'currency', currency:'IDR', maximumFractionDigits:0 }).format(v);
    const fmtNum = (v, dec=8) => Number(v).toFixed(dec);
    const now = () => new Date().toLocaleTimeString('id-ID', { hour12:false });

    // ===== Pair presets =====
    const PAIRS = {
      'BTC/IDR': { tick: 950_000_000, base:'BTC', quote:'IDR', baseInit:0.05, idrInit:100_000_000 },
      'ETH/IDR': { tick: 45_000_000, base:'ETH', quote:'IDR', baseInit:1.5, idrInit:100_000_000 },
      'DOGE/IDR': { tick: 2_500, base:'DOGE', quote:'IDR', baseInit:5000, idrInit:100_000_000 }
    };

    const state = {
      activePair: 'BTC/IDR',
      perPair: {},
      fees: { taker: 0.001, maker: 0.0 },
    };

    function initPair(key){
      const p = PAIRS[key];
      state.perPair[key] = {
        balance: { IDR: p.idrInit, BASE: p.baseInit },
        bids: [], asks: [], trades: [],
        lastPrice: p.tick, open24: p.tick*0.98,
        high24: p.tick*1.03, low24: p.tick*0.97, vol24: 0
      };
      seedBook(key);
    }
    Object.keys(PAIRS).forEach(initPair);

    // ===== Elements =====
    const el = {
      currentPair: document.getElementById('currentPair'),
      tabs: document.querySelectorAll('.tab'),

      // summary
      mLast: document.getElementById('mLast'),
      mBid: document.getElementById('mBid'),
      mAsk: document.getElementById('mAsk'),
      mSpread: document.getElementById('mSpread'),
      mChange: document.getElementById('mChange'),
      mHigh: document.getElementById('mHigh'),
      mLow: document.getElementById('mLow'),
      mVol: document.getElementById('mVol'),

      // order entry
      orderType: document.getElementById('orderType'),
      orderSide: document.getElementById('orderSide'),
      price: document.getElementById('price'),
      qty: document.getElementById('qty'),
      placeBuy: document.getElementById('placeBuy'),
      placeSell: document.getElementById('placeSell'),
      reset: document.getElementById('reset'),
      cancelBids: document.getElementById('cancelBids'),
      cancelAsks: document.getElementById('cancelAsks'),
      clearTrades: document.getElementById('clearTrades'),
      balIDR: document.getElementById('balIDR'),
      balBase: document.getElementById('balBase'),
      tradesBody: document.getElementById('tradesBody'),

      // depth chart
      depthChart: document.getElementById('depthChart')
    };

    // ===== Depth chart (Chart.js area for bids/asks) =====
    const depth = new Chart(el.depthChart, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label:'Bids', data: [], borderColor:'#00c389', backgroundColor:'rgba(0,195,137,0.18)', fill:true, tension:0.2, pointRadius:0 },
          { label:'Asks', data: [], borderColor:'#ff5c7a', backgroundColor:'rgba(255,92,122,0.15)', fill:true, tension:0.2, pointRadius:0 }
        ]
      },
      options: {
        responsive:true, animation:false,
        plugins:{ legend:{ display:false }, tooltip:{ mode:'index', intersect:false } },
        scales:{
          x:{ ticks:{ color:'#93a1b3', maxRotation:0 }, grid:{ display:false } },
          y:{ ticks:{ color:'#93a1b3' }, grid:{ color:'#1b2333' } }
        }
      }
    });

    function updateDepth(S){
      const agg = (orders, side) => {
        const map = new Map();
        orders.forEach(o => map.set(o.price, (map.get(o.price)||0) + o.qty));
        const arr = Array.from(map.entries()).map(([price, qty])=>({ price, qty }))
          .sort((a,b)=> side==='bid' ? b.price - a.price : a.price - b.price)
          .slice(0, 15);
        let cum = 0;
        return arr.map(x => { cum += x.qty; return { price:x.price, cum }; });
      };
      const bids = agg(S.bids, 'bid');
      const asks = agg(S.asks, 'ask');

      const labels = [...bids.map(b=>b.price).reverse(), ...asks.map(a=>a.price)];
      const bidSeries = [...bids.map(b=>b.cum).reverse(), ...new Array(asks.length).fill(null)];
      const askSeries = [...new Array(bids.length).fill(null), ...asks.map(a=>a.cum)];

      depth.data.labels = labels;
      depth.data.datasets[0].data = bidSeries;
      depth.data.datasets[1].data = askSeries;
      depth.update();
    }

    // ===== Engine =====
    function getS(){ return state.perPair[state.activePair]; }

    function render(){
      const S = getS();
      // sort books
      S.bids.sort((a,b)=> b.price - a.price || a.ts - b.ts);
      S.asks.sort((a,b)=> a.price - b.price || a.ts - b.ts);

      const bestBid = S.bids[0]?.price ?? null;
      const bestAsk = S.asks[0]?.price ?? null;

      // summary
      el.mLast.textContent = fmtIDR(S.lastPrice);
      el.mBid.textContent = bestBid ? fmtIDR(bestBid) : '—';
      el.mAsk.textContent = bestAsk ? fmtIDR(bestAsk) : '—';
      el.mSpread.textContent = (bestBid&&bestAsk) ? fmtIDR(bestAsk - bestBid) : '—';
      const chg = (S.lastPrice - S.open24) / S.open24 * 100;
      el.mChange.textContent = (chg>=0?'+':'') + chg.toFixed(2) + '%';
      el.mHigh.textContent = fmtIDR(S.high24);
      el.mLow.textContent = fmtIDR(S.low24);
      el.mVol.textContent = fmtNum(S.vol24, 4);

      // balances
      const pair = PAIRS[state.activePair];
      el.balIDR.textContent = fmtIDR(S.balance.IDR);
      el.balBase.textContent = fmtNum(S.balance.BASE) + ' ' + pair.base;

      // trades table
      el.tradesBody.innerHTML = S.trades.slice().reverse().map(t =>
        `<tr>
          <td style="text-align:left">${t.time}</td>
          <td>${fmtIDR(t.price)}</td>
          <td>${fmtNum(t.qty,6)}</td>
          <td>${fmtIDR(t.price * t.qty)}</td>
          <td class="${t.side==='buy'?'buyText':'sellText'}">${t.side.toUpperCase()}</td>
        </tr>`
      ).join('');

      // charts
      updateDepth(S);
    }

    function recordTrade(t){
      const S = getS();
      S.lastPrice = t.price;
      S.vol24 += t.qty;
      S.high24 = Math.max(S.high24, t.price);
      S.low24 = Math.min(S.low24, t.price);
      S.trades.push({ time: now(), ...t });
    }

    function addOrder({ side, price, qty }){
      const S = getS();
      const type = el.orderType.value;
      if(qty <= 0) return;
      if(type==='limit' && price <= 0) return;

      const order = { side, price, qty, ts: performance.now() };

      if(side === 'buy'){
        while(order.qty > 0 && S.asks.length){
          const best = S.asks[0];
          if(type==='limit' && best.price > order.price) break;
          const take = Math.min(order.qty, best.qty);
          const fee = (type==='market' ? state.fees.taker : state.fees.maker) * best.price * take;
          const cost = best.price * take + fee;
          if(S.balance.IDR < cost) break;

          S.balance.IDR -= cost;
          S.balance.BASE += take;

          best.qty -= take;
          order.qty -= take;
          recordTrade({ side:'buy', price: best.price, qty: take });
          if(best.qty <= 0) S.asks.shift();
        }
        if(order.qty > 0 && type==='limit'){
          S.bids.push({ price: order.price, qty: order.qty, ts: order.ts });
        }
      } else {
        while(order.qty > 0 && S.bids.length){
          const best = S.bids[0];
          if(type==='limit' && best.price < order.price) break;
          const take = Math.min(order.qty, best.qty);
          const fee = (type==='market' ? state.fees.taker : state.fees.maker) * best.price * take;
          if(S.balance.BASE < take) break;

          S.balance.BASE -= take;
          S.balance.IDR += best.price * take - fee;

          best.qty -= take;
          order.qty -= take;
          recordTrade({ side:'sell', price: best.price, qty: take });
          if(best.qty <= 0) S.bids.shift();
        }
        if(order.qty > 0 && type==='limit'){
          S.asks.push({ price: order.price, qty: order.qty, ts: order.ts });
        }
      }
      render();
    }

    function executeMarket({ side, qty }){
      const S = getS();
      if(qty <= 0) return;
      if(side==='buy'){
        while(qty > 0 && S.asks.length){
          const ask = S.asks[0];
          const take = Math.min(qty, ask.qty);
          const fee = state.fees.taker * ask.price * take;
          const cost = ask.price * take + fee;
          if(S.balance.IDR < cost) break;

          S.balance.IDR -= cost;
          S.balance.BASE += take;
          ask.qty -= take;
          qty -= take;
          recordTrade({ side:'buy', price: ask.price, qty: take });
          if(ask.qty <= 0) S.asks.shift();
        }
      } else {
        while(qty > 0 && S.bids.length){
          const bid = S.bids[0];
          const take = Math.min(qty, bid.qty);
          const fee = state.fees.taker * bid.price * take;
          if(S.balance.BASE < take) break;

          S.balance.BASE -= take;
          S.balance.IDR += bid.price * take - fee;
          bid.qty -= take;
          qty -= take;
          recordTrade({ side:'sell', price: bid.price, qty: take });
          if(bid.qty <= 0) S.bids.shift();
        }
      }
      render();
    }

    // ===== Simulation =====
    function seedBook(pairKey){
      const S = state.perPair[pairKey];
      const baseTick = PAIRS[pairKey].tick;
      S.bids = [
        { price: Math.floor(baseTick*0.99), qty: 0.020, ts: performance.now() },
        { price: Math.floor(baseTick*0.985), qty: 0.030, ts: performance.now()+1 },
        { price: Math.floor(baseTick*0.98), qty: 0.040, ts: performance.now()+2 },
      ];
      S.asks = [
        { price: Math.floor(baseTick*1.01), qty: 0.015, ts: performance.now() },
        { price: Math.floor(baseTick*1.015), qty: 0.025, ts: performance.now()+1 },
        { price: Math.floor(baseTick*1.02), qty: 0.035, ts: performance.now()+2 },
      ];
      S.lastPrice = baseTick;
    }

    function heartbeat(){
      const S = getS();
      const baseTick = PAIRS[state.activePair].tick;

      // random walk
      const drift = (Math.random()-0.5) * baseTick * 0.004;
      S.lastPrice = Math.max(1, Math.floor(S.lastPrice + drift));

      // update 24h stats baseline drift (simulasi)
      S.high24 = Math.max(S.high24, S.lastPrice);
      S.low24 = Math.min(S.low24, S.lastPrice);

      // nudge best bid/ask
      const spread = Math.max(1, Math.floor(baseTick * 0.008 + Math.random()*baseTick*0.004));
      const mid = S.lastPrice;
      const bid = Math.max(1, Math.floor(mid - spread/2));
      const ask = Math.max(1, Math.floor(mid + spread/2));
      if(S.bids.length){ S.bids[0].price = bid; }
      if(S.asks.length){ S.asks[0].price = ask; }

      render();
    }

    // ===== Quick qty buttons =====
    document.querySelectorAll('.quick button').forEach(btn => {
      btn.addEventListener('click', () => {
        const pct = parseFloat(btn.dataset.q);
        const S = getS();
        const side = el.orderSide.value;
        if(side === 'buy'){
          const bestAsk = S.asks[0]?.price ?? S.lastPrice;
          const budget = S.balance.IDR * (pct/100);
          const est = Math.max(0, budget / bestAsk);
          el.qty.value = (est || 0).toFixed(6);
        } else {
          el.qty.value = (S.balance.BASE * (pct/100)).toFixed(6);
        }
      });
    });

    // ===== Events =====
    el.placeBuy.addEventListener('click', () => {
      const type = el.orderType.value;
      const qty = parseFloat(el.qty.value || '0');
      if(type==='market') executeMarket({ side:'buy', qty });
      else {
        const price = parseFloat(el.price.value || '0');
        addOrder({ side:'buy', price, qty });
      }
    });
    el.placeSell.addEventListener('click', () => {
      const type = el.orderType.value;
      const qty = parseFloat(el.qty.value || '0');
      if(type==='market') executeMarket({ side:'sell', qty });
      else {
        const price = parseFloat(el.price.value || '0');
        addOrder({ side:'sell', price, qty });
      }
    });

    el.reset.addEventListener('click', () => {
      const key = state.activePair;
      state.perPair[key].balance = { IDR: PAIRS[key].idrInit, BASE: PAIRS[key].baseInit };
      state.perPair[key].trades = [];
      state.perPair[key].vol24 = 0;
      seedBook(key);
      render();
    });
    el.cancelBids.addEventListener('click', () => { getS().bids = []; render(); });
    el.cancelAsks.addEventListener('click', () => { getS().asks = []; render(); });
    el.clearTrades.addEventListener('click', () => { getS().trades = []; render(); });

    // Tabs switch: update pair state + TradingView symbol
    function onPairChange(pair){
      state.activePair = pair;
      el.currentPair.textContent = pair;
      seedBook(pair);
      render();
      const sym = TV_SYMBOLS[pair] || 'BINANCE:BTCUSDT';
      mountTV(sym);
    }
    el.tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        el.tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        onPairChange(tab.dataset.pair);
      });
    });

    // Init
    seedBook(state.activePair);
    render();
    mountTV(TV_SYMBOLS[state.activePair] || 'BINANCE:BTCUSDT');
    setInterval(heartbeat, 1000);
  </script>
</body>
</html>